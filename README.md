# Game Programming Gems   

##  Game Programming Gems 1  

### Section 4 Polygonal Techniques  
4.0 Optimizing Vertex Submissions for OpenGL  
4.1 Tweaking A Vertex's Projected Depth Value  
4.2 The Vector Camera  
4.3 Camera Control Techniques  
4.4 A Fast Cylinder-Frustum Intersection Test  
4.5 3D Collision Detection  
4.6 Multi-Resolution Maps for Interaction Detection  
4.7 Computing the Distance into a Sector  
4.8 Object Occlusion Culling  
4.9 Never Let 'Em See You Pop - Issues in Geometric Level of Detail Selection  
4.10 Octree Construction  
4.11 Loose Octrees  
4.12 View-Independent Progressive Meshing  
4.13 Interpolated 3D Keyframe Animation  
4.14 A Fast and Simple Skinning Techniques  
4.15 Filling the Gaps - Advanced Animation Using Stitching and Skinning  
4.16 Real-Time Realistic Terrain Generation  
4.17 Fractal Terrain Generation - Fault Formation  
4.18 Fractal Terrain Generation - Midpoint Displacement 
4.19 Fractal Terrain Generation - Particle Deposition  

### Section 5 Pixel Effects  
5.0 2D Lens Flare  
5.1 Using 3D Hardware for 2D Sprite Effects  
5.2 Motif-Based Static Lighting  
5.3 Simulated Real-Time Lighting Using Vertex Color Interpolation  
5.4 Attenuation Maps  
5.5 Advanced Texturing Using Texture Coordinate Generation  
5.6 Hardware Bump Mapping  
5.7 Ground-Plane Shadows  
5.8 Real-Time Shadows on Complex Objects  
5.9 Improving Environment-Mapped Reflection Using Glossy Prefiltering and the Fresnel Term  
5.10 Convincing-Looking Glass for Games  
5.11 Refraction Mapping for Liquids in Containers  

##  Game Programming Gems 2

### Section 4 - Geometry Management 
4.1 Comparison of VIPM Methods  
4.2 Simplified Terrain Using Interlocking Tiles  
4.3 Sphere Trees for Fast Visibility Culling, Ray Tracing, and Range Searching  
4.4 Compressed Axis-Aligned Bounding Box Trees  
4.5 Direct Access Quadtree Lookup  
4.6 Approximating Fish Tank Refractions  
4.7 Rendering Print Resolution Screenshots  
4.8 Applying Decals to Arbitrary Surfaces  
4.9 Rendering Distant Scenery with Skyboxes  
4.10 Self-Shadowing Characters  
4.11 Classic Super Mario 64 Third-Person Control and Animation  

### Section 5 - Graphics Display 
5.1 Cartoon Rendering: Real-time Silhouette Edge Detection and Rendering  
5.2 Cartoon Rendering Using Texture Mapping and Programmable Vertex Shaders  
5.3 Dynamic Per-Pixel Lighting Techniques  
5.4 Generating Procedural Clouds Using 3D Hardware  
5.5 Texture Masking for Faster Lens Flare  
5.6 Practical Priority Buffer Shadows  
5.7 Impostors: Adding Clutter  
5.8 Operations for Hardware-Accelerated Procedural Texture Animation  

##  Game Programming Gems 3

### Section 4 Graphics  
4.1 T-Junction Elimination and Retriangulation  
4.2 Fast Heightfield Normal Calculation  
4.3 Fast Patch Normals  
4.4 Fast and Simple Occlusion Culling  
4.5 Triangle Strip Creation, Optimizations, and Rendering  
4.6 Computing Optimized Shadow Volumes for Complex Data Sets  
4.7 Subdivision Surfaces for Character Animation  
4.8 Improved Deformation of Bones  
4.9 A Framework for Realistic Character Locomotion  
4.10 A Programmable Vertex Shader Compiler  
4.11 Billboard Beams  
4.12 3D Tricks for Isometric Engines 
4.13 Curvature Simulation Using Normal Maps  
4.14 Methods for Dynamic, Photorealistic Terrain Lighting  
4.15 Cube Map Lighting Techniques  
4.16 Procedural Texturing  
4.17 Unique Textures  
4.18 Textures as Lookup Tables for Per-Pixel Lighting Computations  
4.19 Rendering with Handcrafted Shading Models  

##  Game Programming Gems 4

### Section 5 Graphics  
5.1 Poster Quality Screenshots  
5.2 GPU Shadow Volume Construction for Nonclosed Meshes  
5.3 Perspective Shadow Maps  
5.4 Combined Depth and ID-Based Shadow Buffers  
5.5 Carving Static Shadows into Geometry  
5.8 Techniques to Apply Team Colors to 3D Models  
5.9 Fast Sepia Tone Conversion  
5.10 Dynamic Gamma Using Sampled Scene Luminance  
5.11 Heat and Haze Post-Processing Effects  
5.13 Motion Capture Data Compression  
5.14 Fast Collision Detection for 3D Bones-Based Articulated Characters  
5.15 Terrain Occlusion Culling with Horizons  

##  Game Programming Gems 5

### Section 5 Graphics  
5.1 Realistic Cloud Rendering on Modern GPUs  
5.2 Let It Snow, Let It Snow, Let It Snow (and Rain)  
5.3 Widgets: Rendering Fast and Persistent Foliage  
5.4 2.5 Dimensional Impostors for Realistic Trees and Forests  
5.5 Gridless Controllable Fire  
5.6 Powerful Explosion Effects Using Billboard Particles  
5.7 A Simple Method for Rendering Gemstones  
5.8 Volumetric Post-Processing  
5.9 Procedural Level Generation  
5.10 Recombinant Shaders  

##  Game Programming Gems 6

### Section 5 Graphics  
5.1 Synthesis of Realistic Idle Motion for Interactive Characters  
5.2 Spatial Partitioning Using an Adaptive Binary Tree  
5.3 Enhanced Object Culling with (Almost) Oriented Bounding Boxes  
5.4 Skin Splitting for Optimal Rendering  
5.5 GPU Terrain Rendering  
5.6 Interactive Fluid Dynamics and Rendering on the GPU  
5.7 Fast Per-Pixel Lighting with Many Lights  
5.8 Rendering Road Signs Sharply  
5.9 Practical Sky Rendering for Games  
5.10 High Dynamic Range Rendering Using OpenGL Frame Buffer Objects   

##  Game Programming Gems 7

### Section 5 Graphics  
5.1. Advanced Particle Deposition   
5.2. Reducing Cumulative Errors in Skeletal Animations    
5.3. An Alternative Model for Shading of Diffuse Light for Rough Materials    
5.4. High-Performance Subdivision Surfaces   
5.5. Animating Relief Impostors Using Radial Basis Functions Textures    
5.6. Clipmapping on SM1.1 and Higher   
5.7. An Advanced Decal System   
5.8. Mapping Large Textures for Outdoor Terrain Rendering   
5.9. Art-Based Rendering with Graftal Imposters   
5.10. Cheap Talk: Dynamic Real-Time Lipsync   

##  Game Programming Gems 8

### Section 1 Graphics
1.1 Fast Font Rendering with Instancing  
1.2 Principles and Practice of Screen Space Ambient Occlusion  
1.3 Multi-Resolution Deferred Shading  
1.4 View Frustum Culling of Catmull-Clark Patches in DirectX 11  
1.5 Ambient Occlusion Using DirectX Compute Shader  
1.6 Eye-View Pixel Anti-Aliasing for Irregular Shadow Mapping  
1.7 Overlapped Execution on Programmable Graphics Hardware  
1.8 Techniques for Effective Vertex and Fragment Shading on the SPUs  

# Game Engine Gems

## Game Engine Gems, Volume 1

### Part II — Rendering Techniques  
15. Physically-Based Outdoor Scene Lighting  
16. Rendering Physically-Based Skyboxes  
17. Motion Blur and the Velocity-Depth-Gradient Buffer  
18. Fast Screen-space Ambient Occlusion and Indirect Lighting  
19. Real-Time Character Dismemberment  
20. A Deferred Decal Rendering Technique  


## Game Engine Gems, Volume 2

### Part I — Graphics and Rendering  
1. Fast Computation of Tight-Fitting Oriented Bounding Boxes  
2. Modeling, Lighting, and Rendering Techniques for Volumetric Clouds  
3. Simulation of Night-Vision and Infrared Sensors  
4. Screen-Space Classification for Efficient Deferred Shading  
5. Delaying OpenGL Calls  
6. A Framework for GLSL Engine Uniforms  
7. A Spatial and Temporal Coherence Framework for Real-Time Graphics  
8. Implementing a Fast Diffusion DOF Solver  
9. Automatic Dynamic Stereoscopic 3D  
10. Practical Stereo Rendering  
11. Making 3D Stereoscopic Games  
12. A Generic Multi-View Rendering Engine Architecture  
13. 3D in a Web Browser  
14. 2D Magic  

## Game Engine Gems, Volume 3  

### Part I — Graphics and Rendering    
1. The Open Game Engine Exchange Format  
2. Realistic Blending of Skies, Water, and Terrain  
3. Fog with a Linear Density Function  
4. Vegetation Management in Leadwerks Game Engine 4  
5. Smooth Horizon Mapping  
6. Buffer-Free Generation of Triangle Strip Cube Vertices  
7. Edge-Preserving Smoothing Filter for Particle Based Rendering  
8. Variable Precision Pixel Shading for Improved Power Efficiency  
9. A Fast and High-Quality Texture Atlasing Algorithm  

# Insights

## OpenGL Insights

Teaching Computer Graphics Starting with Shader-Based OpenGL  
Transitioning Students to Post-Deprecation OpenGL  
WebGL for OpenGL Developers  
Porting Mobile Apps to WebGL  
The GLSL Shader Interfaces  
An Introduction to Tessellation Shaders  
Procedural Textures in GLSL  
OpenGL SC Emulation Based on OpenGL and OpenGL ES  
Mixing Graphics and Compute with Multiple GPUs  
GPU Tessellation: We Still Have a LOD of Terrain to Cover  
Antialiased Volumetric Lines Using Shader-Based Extrusion  
2D Shape Rendering by Distance Fields  
Efficient Text Rendering in WebGL  
Layered Textures Rendering Pipeline  
Depth of Field with Bokeh Rendering  
Real-Time Physically Based Deformation Using Transform Feedback  
Hierarchical Depth Culling and Bounding-Box Management on the GPU  
Massive Number of Shadow-Casting Lights with Layered Rendering  
Efficient Layered Fragment Buffer Techniques  
Programmable Vertex Pulling  
Octree-Based Sparse Voxelization Using the GPU Hardware Rasterizer  
Performance Tuning for Tile-Based Architectures  
Exploring Mobile vs. Desktop OpenGL Performance  
Improving Performance by Reducing Calls to the Driver  
Indexing Multiple Vertex Arrays  
Multi-GPU Rendering on NVIDIA Quadro  
Asynchronous Buffer Transfers  
Fermi Asynchronous Texture Transfers  
WebGL Models: End-to-End  
In-Game Video Capture with Real-Time Texture Compression  
An OpenGL-Friendly Geometry File Format and Its Maya Exporter  
ARB_debug_output: A Helping Hand for Desperate Developers  
The OpenGL Timer Query  
A Real-Time Profiling Tool  
Browser Graphics Analysis and Optimizations  
Performance State Tracking  
Monitoring Graphics Memory Usage  
The ANGLE Project: Implementing OpenGL ES 2.0 on Direct3D  
SceneJS: A WebGL-Based Scene Graph Engine  
Features WebGL and Design Choices in SpiderGL  
Multimodal Interactive Simulations on the Web
A Subset Approach to Using OpenGL and OpenGL ES  
Jesse Barker, Alexandros Frantzis  
The Build Syndrome  

## WebGL Insights

ANGLE: A Desktop Foundation for WebGL  
Mozilla's Implementation of WebGL  
Continuous Testing of Chrome's WebGL Implementation  
Getting Serious with JavaScript  
Emscripten & WebGL  
Data Visualization with WebGL: from Python to JavaScript  
Teaching an Introductory Computer Graphics Course with WebGL  
Bug-Free and Fast Mobile WebGL  
WebGL Engine Design in Babylon.js  
Rendering Optimizations in the Turbulenz Engine  
Performance and Rendering Algorithms in Blend4Web  
Sketchfab Material Pipeline: From File Variations to Shader Generation  
glslify: A module system for GLSL  
Budgeting Frame Time  
Deferred Shading in Luma  
HDR Image-Based Lighting on the Web  
Real-Time Volumetric Lighting for WebGL  
Terrain Geometry – LOD Adapting Concentric Rings    
Data Visualization Techniques with WebGL  
hare3d - Rendering Large Models in the Browser  
The BrainBrowser Surface Viewer: WebGL-based Neurological Data Visualization  
Usability of WebGL Applications  
Designing Cameras for WebGL Applications  

# GPU Gems

## GPU Gems 1

### Part I: Natural Effects  
Chapter 1. Effective Water Simulation from Physical Models  
Chapter 2. Rendering Water Caustics  
Chapter 3. Skin in the "Dawn" Demo  
Chapter 4. Animation in the "Dawn" Demo  
Chapter 5. Implementing Improved Perlin Noise  
Chapter 6. Fire in the "Vulcan" Demo  
Chapter 7. Rendering Countless Blades of Waving Grass  
Chapter 8. Simulating Diffraction  
### Part II: Lighting and Shadows  
Chapter 9. Efficient Shadow Volume Rendering  
Chapter 10. Cinematic Lighting  
Chapter 11. Shadow Map Antialiasing  
Chapter 12. Omnidirectional Shadow Mapping  
Chapter 13. Generating Soft Shadows Using Occlusion Interval Maps  
Chapter 14. Perspective Shadow Maps: Care and Feeding  
Chapter 15. Managing Visibility for Per-Pixel Lighting  
### Part III: Materials  
Chapter 16. Real-Time Approximations to Subsurface Scattering  
Chapter 17. Ambient Occlusio  
Chapter 18. Spatial BRDFs  
Chapter 19. Image-Based Lighting  
Chapter 20. Texture Bombing  
### Part IV: Image Processing  
Chapter 21. Real-Time Glow  
Chapter 22. Color Controls  
Chapter 23. Depth of Field: A Survey of Techniques  
Chapter 24. High-Quality Filtering  
Chapter 25. Fast Filter-Width Estimates with Texture Maps  
Chapter 26. The OpenEXR Image File Format  
Chapter 27. A Framework for Image Processing  
### Part V: Performance and Practicalities  
Chapter 28. Graphics Pipeline Performance  
Chapter 29. Efficient Occlusion Culling  
Chapter 30. The Design of FX Composer  
Chapter 31. Using FX Composer  
Chapter 32. An Introduction to Shader Interfaces  
Chapter 33. Converting Production RenderMan Shaders to Real-Time  
Chapter 34. Integrating Hardware Shading into Cinema 4D  
Chapter 35. Leveraging High-Quality Software Rendering Effects in Real-Time Applications  
Chapter 36. Integrating Shaders into Applications  
### Part VI: Beyond Triangles  
Chapter 37. A Toolkit for Computation on GPUs  
Chapter 38. Fast Fluid Dynamics Simulation on the GPU  
Chapter 39. Volume Rendering Techniques  
Chapter 40. Applying Real-Time Shading to 3D Ultrasound Visualization  
Chapter 41. Real-Time Stereograms  
Chapter 42. Deformers  
  
## GPU Gems 2  
  
### Part I: Geometric Complexity  
Chapter 1. Toward Photorealism in Virtual Botany  
Chapter 2. Terrain Rendering Using GPU-Based Geometry Clipmaps  
Chapter 3. Inside Geometry Instancing  
Chapter 4. Segment Buffering  
Chapter 5. Optimizing Resource Management with Multistreaming  
Chapter 6. Hardware Occlusion Queries Made Useful  
Chapter 7. Adaptive Tessellation of Subdivision Surfaces with Displacement Mapping  
Chapter 8. Per-Pixel Displacement Mapping with Distance Functions  
### Part II: Shading, Lighting, and Shadows  
Chapter 9. Deferred Shading in S.T.A.L.K.E.R.  
Chapter 10. Real-Time Computation of Dynamic Irradiance Environment Maps  
Chapter 11. Approximate Bidirectional Texture Functions  
Chapter 12. Tile-Based Texture Mapping  
Chapter 13. Implementing the mental images Phenomena Renderer on the GPU  
Chapter 14. Dynamic Ambient Occlusion and Indirect Lighting  
Chapter 15. Blueprint Rendering and "Sketchy Drawings"  
Chapter 16. Accurate Atmospheric Scattering  
Chapter 17. Efficient Soft-Edged Shadows Using Pixel Shader Branching  
Chapter 18. Using Vertex Texture Displacement for Realistic Water Rendering  
Chapter 19. Generic Refraction Simulation  
### Part III: High-Quality Rendering  
Chapter 20. Fast Third-Order Texture Filtering  
Chapter 21. High-Quality Antialiased Rasterization  
Chapter 22. Fast Prefiltered Lines  
Chapter 23. Hair Animation and Rendering in the Nalu Demo  
Chapter 24. Using Lookup Tables to Accelerate Color Transformations  
Chapter 25. GPU Image Processing in Apple's Motion  
Chapter 26. Implementing Improved Perlin Noise  
Chapter 27. Advanced High-Quality Filtering  
Chapter 28. Mipmap-Level Measurement  
### Part IV: General-Purpose Computation on GPUS: A Primer  
Chapter 29. Streaming Architectures and Technology Trends  
Chapter 30. The GeForce 6 Series GPU Architecture  
Chapter 31. Mapping Computational Concepts to GPUs  
Chapter 32. Taking the Plunge into GPU Computing  
Chapter 33. Implementing Efficient Parallel Data Structures on GPUs  
Chapter 34. GPU Flow-Control Idioms  
Chapter 35. GPU Program Optimization  
Chapter 36. Stream Reduction Operations for GPGPU Applications  
### Part V: Image-Oriented Computing  
Chapter 37. Octree Textures on the GPU  
Chapter 38. High-Quality Global Illumination Rendering Using Rasterization  
Chapter 39. Global Illumination Using Progressive Refinement Radiosity  
Chapter 40. Computer Vision on the GPU  
Chapter 41. Deferred Filtering: Rendering from Difficult Data Formats  
Chapter 42. Conservative Rasterization  
### Part VI: Simulation and Numerical Algorithms  
Chapter 43. GPU Computing for Protein Structure Prediction  
Chapter 44. A GPU Framework for Solving Systems of Linear Equations  
Chapter 45. Options Pricing on the GPU  
Chapter 46. Improved GPU Sorting  
Chapter 47. Flow Simulation with Complex Boundaries  
Chapter 48. Medical Image Reconstruction with the FFT  
  
## GPU Gems 3  
  
### Part I: Geometry  
Chapter 1. Generating Complex Procedural Terrains Using the GPU  
Chapter 2. Animated Crowd Rendering  
Chapter 3. DirectX 10 Blend Shapes: Breaking the Limits  
Chapter 4. Next-Generation SpeedTree Rendering  
Chapter 5. Generic Adaptive Mesh Refinement  
Chapter 6. GPU-Generated Procedural Wind Animations for Trees  
Chapter 7. Point-Based Visualization of Metaballs on a GPU  
### Part II: Light and Shadows  
Chapter 8. Summed-Area Variance Shadow Maps  
Chapter 9. Interactive Cinematic Relighting with Global Illumination  
Chapter 10. Parallel-Split Shadow Maps on Programmable GPUs  
Chapter 11. Efficient and Robust Shadow Volumes Using Hierarchical Occlusion Culling and Geometry Shaders  
Chapter 12. High-Quality Ambient Occlusion  
Chapter 13. Volumetric Light Scattering as a Post-Process  
### Part III: Rendering  
Chapter 14. Advanced Techniques for Realistic Real-Time Skin Rendering  
Chapter 15. Playable Universal Capture  
Chapter 16. Vegetation Procedural Animation and Shading in Crysis  
Chapter 17. Robust Multiple Specular Reflections and Refractions  
Chapter 18. Relaxed Cone Stepping for Relief Mapping  
Chapter 19. Deferred Shading in Tabula Rasa  
Chapter 20. GPU-Based Importance Sampling  
### Part IV: Image Effects  
Chapter 21. True Impostors  
Chapter 22. Baking Normal Maps on the GPU  
Chapter 23. High-Speed, Off-Screen Particles  
Chapter 24. The Importance of Being Linear  
Chapter 25. Rendering Vector Art on the GPU  
Chapter 26. Object Detection by Color: Using the GPU for Real-Time Video Image Processing  
Chapter 27. Motion Blur as a Post-Processing Effect  
Chapter 28. Practical Post-Process Depth of Field  
### Part V: Physics Simulation  
Chapter 29. Real-Time Rigid Body Simulation on GPUs  
Chapter 30. Real-Time Simulation and Rendering of 3D Fluids  
Chapter 31. Fast N-Body Simulation with CUDA  
Chapter 32. Broad-Phase Collision Detection with CUDA  
Chapter 33. LCP Algorithms for Collision Detection Using CUDA  
Chapter 34. Signed Distance Fields Using Single-Pass GPU Scan Conversion of Tetrahedra  
Chapter 35. Fast Virus Signature Matching on the GPU  
### Part VI: GPU Computing  
Chapter 36. AES Encryption and Decryption on the GPU  
Chapter 37. Efficient Random Number Generation and Application Using CUDA  
Chapter 38. Imaging Earth's Subsurface Using CUDA  
Chapter 39. Parallel Prefix Sum (Scan) with CUDA  
Chapter 40. Incremental Computation of the Gaussian  
Chapter 41. Using the Geometry Shader for Compact and Variable-Length GPU Feedback  
  
# ShaderX  

## Shaderx 1 Vertex and Pixel Shader Tips and Tricks  

### Part 1: Introduction to Shader Programming  
### Part 2: Vertex Shader Tricks  
Vertex Decompression in a Shader  
Shadow Volume Extrusion Using a Vertex Shader  
Character Animation with Direct3D Vertex Shaders  
Lighting a Single-Surface Object  
Optimizing Software Vertex Shaders  
Compendium of Vertex Shader Tricks  
Perlin Noise and Returning Results from Shader Programs   
### Part 3: Pixel Shader Tricks  
Blending Textures for Terrain  
Image Processing with 1.4 Pixel Shaders in Direct3D  
Hallo World -- Font Smoothing with Pixel Shaders  
Emulating Geometry with Shaders -- Imposters  
Smooth Lighting with ps.1.4   
Per-Pixel Fresnel Term  
Diffuse Cube Mapping  
Accurate Reflections and Refractions  
UV Flipping Technique to Avoid Repetition  
Photorealistic Faces with Vertex and Pixel Shaders  
Non-Photorealistic Rendering with Pixel and Vertex Shaders  
Animated Grass with Pixel and Vertex Shaders  
Texture Perturbation Effects  
Rendering Ocean Water  
Rippling Reflective and Refractive Water  
Crystal/Candy Shader  
Bubble Shader  
Per-Pixel Strand-Based Anisotropic Lighting  
A Non-Integer Power Function on the Pixel Shader  
Bump Mapped BRDF Rendering  
Real-Time Simulation and Rendering of Particle Flows  
### Part 4: Using 3D Textures with Shaders  
3D Textures and Pixel Shaders  
Truly Volumetric Effects  
### Part 5: Engine Design with Shaders  
First Thoughts on Designing a Shader-Driven Game Engine  
Visualization with the Krass Game Engine   
Designing a Vertex Shader-Driven 3D Engine for the Quake III Format  
  
## ShaderX2 - Introductions and Tutorials with DirectX9  
  
Introduction to the DirectX High Level Shading Language 1  
Introduction to the vs_3_0 and ps_3_0 Shader Models   
Advanced Lighting and Shading with Direct3D 9   
Introduction to Different Fog Effects  
Shadow Mapping with Direct3D 9   
The Theory of Stencil Shadow Volumes   
Shader Development Using RenderMonkey   
Tips for Creating Shader-Friendly 3D Models   
  
## ShaderX2 Shader Programming Tips Tricks with DirectX9  
### Section I - Geometry Manipulation Tricks   
Using Vertex Shaders for Geometry Compression   
Using Lookup Tables in Vertex Shaders   
Terrain Geomorphing in the Vertex Shader   
3D Planets on the GPU   
Cloth Animation with Pixel and Vertex Shader   
Collision Shaders   
Displacement Mapping   
### Section II - Rendering Techniques   
Rendering Objects as Thick Volumes   
Screen-aligned Particles with Minimal VertexBuffer Locking  
Hemisphere Lighting with Radiosity Maps  
Galaxy Textures   
Turbulent Sun   
Fragment-level Phong Illumination  
Specular Bump Mapping on Pre-ps_1_4 Hardware  
Voxel Rendering with PS_3_0 161  
Simulating Blending Operations on Floating-point Render Targets   
Rendering Volumes in a Vertex & Pixel Program by Ray Tracing   
Normal Map Compression   
Drops of Water and Texture Sprites  
Advanced Water Effects   
Efficient Evaluation of Irradiance Environment Maps  
Practical Precomputed Radiance Transfer   
Advanced Sky Dome Rendering   
Deferred Shading with Multiple Render Targets  
Meshuggah＊s Effects Explained   
Layered Car Paint Shader   
Motion Blur Using Geometry and Shading Distortion   
Simulation of Iridescence and Translucency on Thin Surfaces   
Floating-point Cube Maps   
Stereoscopic Rendering in Hardware Using Shaders   
Hatching, Stroke Styles, and Pointillism   
Layered Fog   
Dense Matrix Algebra on the GPU   
### Section III - Software Shaders and Shader Programming Tips   
Software Vertex Shader Processing   
x86 Shaders-ps_2_0 Shaders in Software  
SoftD3D: A Software-only Implementation of Microsoft＊s Direct3D API   
Named Constants in Shader Development   
### Section IV - Image Space   
Advanced Image Processing with DirectX 9 Pixel Shaders   
Night Vision: Frame Buffer Post-processing with ps.1.1 Hardware  
Non-Photorealistic Post-processing Filters in MotoGP 2   
Image Effects with DirectX 9 Pixel Shaders  
Using Pixel Shaders to Implement a Mosaic Effect Using Character Glyphs   
Mandelbrot Set Rendering   
Real-Time Depth of Field Simulation   
### Section V - Shadows   
Soft Shadows   
Robust Object ID Shadows   
Reverse Extruded Shadow Volumes   
### Section VI - 3D Engine and Tools Design   
Shader Abstraction   
Post-Process Fun with Effects Buffers   
Shaders under Control (Codecreatures Engine)   
Shader Integration in the Gamebryo Graphics Engine   
Vertex Shader Compiler   
Shader Disassembler   
  
## ShaderX 3  
## Section 1 - Introduction and Geometry Manipulation   
1.1 Accessing and modifying topology on the GPU   
1.2 Rendering of Complex Formulas   
1.3 Deforming of Mesh Objects using HLSL  
1.4 Morphing between two different Objects  
1.5 Silhouette Geometry Shaders   
1.6 GLSL Real-time Shader Development   
## Section 2 - Rendering Techniques  
2.1 Parallax Mapping  
2.2 Deferred Lighting on PS 3.0 with High Dynamic Range  
2.3 Reflections from Bumpy Surfaces  
2.4 Massively Parallel Particle Systems on the GPU  
2.5 Parallax Occlusion Mapping: Self-Shadowing, Perspective-Correct Bump Mapping Using Reverse Height Map Tracing  
2.6 Improved Batching Via Texture Atlases  
2.7 A Simulation of Thermal Imaging  
2.8 Real-Time Texture-Space Skin Rendering  
2.9 Dot3 Cel Shading  
2.10 Hardware Accelerated Charcoal Rendering  
2.11 Detail Texture Motion Blur    
2.12 Animation and display of water   
2.13 Rendering Semitransparent Layered Media   
2.14 Hair Rendering and Shading   
2.15 Reduction of lighting calculations using Spherical Harmonics   
## Section 3 - Software Shaders and Shader Programming Tips   
3.1 Optimizing Dx9 Vertex Shaders for Software Vertex Processing  
3.2 Software Shaders and DirectX DLL Implementation  
3.3 Tactical Path-Finding using Stochastic Maps on the GPU   
3.4 FX Composer 1.5 Standardization  
## Section 4 - Image Space   
4.1 A Steerable Streak Filter  
4.2 Adaptive Glare   
4.3 Color Grading  
4.4 Improved Depth of Field Rendering   
4.5 Lighting Precomputation Using the Relighting Map   
4.6 Shaderey - NPR Style Rendering   
## Section 5 - Shadows   
5.1 Poisson Shadow Blur   
5.2 Fractional-Disk Soft Shadows   
5.3 Fake Soft Shadows Using Precomputed Visibility Distance Functions   
5.4 Efficient Omnidirectional Shadow Maps   
## Section 6 - 3D Engine Design  
6.1 An Extensible Direct3D Resource Management System  
6.2 Integrating Shaders into the Vision Rendering Engine   
6.3 Effect Parameters Manipulation Framework   
6.4 Shader Visualization Systems for The Art Pipeline   
6.5 Drawing a Crowd  
## Section 7 -Tools Environmental Effects  
7.1 In-Depth Performance Analyses of DirectX9 Shading Hardware concerning Pixel Shader and Texture Performance  
7.2 Shaderbreaker   
7.3 Generating Shaders From HLSL Fragments   
## Section 8 - Environmental Effects  
8.1 Light Shaft Rendering   
8.2 Rendering Rainbows   
8.3 A Practical Analytic Model for Daylight with Shaders  
8.4 Volumetric Clouds   

## ShaderX 4  

### Section 1 - Geometry Manipulation   
1.1 Better geometry batching using light buffers  
1.2 Practical Cloth Simulation for Modern GPU  
1.3 Shader Implementation of Discrete Wavelet Transform   
1.4 Morph Target Animation   
1.5 Real-Time Character Animation on the GPU   
1.6 Skinning with AniTextures  
### Section 2 - Rendering Techniques   
2.1 Interlaced Rendering   
2.2 Triangle mesh tangent space calculation  
2.3 Hardware-Based Ambient Occlusion 
2.4 Ambient Occlusion Fields     
2.5 Rendering Surface Details with Relief Mapping   
2.6 Real-time Obscurances with Color Bleeding   
2.7 Bump My Shiny Metal   
2.8 Fog Volumes   
2.9Dynamical global illuminations using an environment map  
2.10 Real-time Rendering and Simulation of the Airbrush Media for Metallic Appearance   
2.11 Dynamic Glossy Environment Reflections Using Summed-Area Tables   
2.12 Real-time caustics by GPU   
2.13 Dot-Product for efficient detail texture mapping  
2.14 Real-Time Environment Mapping with Equal Solid-Angle Spherical Quad-Map  
2.15 Reflective Shadow Maps   
### Section 3 - Image Space   
3.1 Texture Compression with Coefficient Domain Shaders   
3.2 Motion Blurring Environment Maps   
3.3 Simulating the Visual Effects of a Video Recording System   
4.1 Soft Projected Shadows  
4.2 Eliminate surface acne with gradient shadow mapping   
4.3 Real-time soft shadows using the PDSM technique   
4.4 Robust Shadow Mapping with Light-Space Perspective Shadow Maps   
4.5 Shadowbuffer Frustum Partitioning   
### Section 5 - 3D Engine Design   
5.1 Tips and Tricks for D3DX Effects Based Renderer   
5.2 Post-Processing Effects using DXSAS   
5.3Case Study: Designing a Shader-Subsystem for a Next-Gen Graphics Engine  
### Section 6 - Beyond Pixels and Triangles  
6.1 Real-time damage deformation methods  
6.2 Ray Tracing Effects without Tracing Rays     
6.3 Implementing Ray-Tracing on the GPU  
6.4 GPU powered path-finding using precomputed Navigation Mesh approach  
### Section 7 - Environmental Effects   
7.1 Winter Wonderland   
7.2 Rendering Snow Cover  
7.3 Cached Procedural Textures for Terrain Rendering   
7.4 A Dynamic Sky System   
7.5 True-to-life Real-time Animation of Shallow Water on Today s GPUs   
### Section 8 - Tools  
8.1 The SuperShader  
8.2 Implementing Radiosity for a Light map Precomputation Tool   
8.3 Indicator Materials   
8.4 Dynamic Branching on non-ps_3_0 Graphics Hardware   
8.5 GLSL Shader Debugging with GLIntercept   
8.6 GPU Performance of DirectX 9 Per-Fragment Operations Revisited  

## ShaderX5- Advanced Rendering Techniques  
### Section 1 - Geometry Manipulation   
1.1 Smoothed N-Patches  
1.2 Micro-beveled Edges   
1.3 Dynamic Wrinkle Patterns and Hatching on Animated Meshes   
1.4 Cloth without Cloth   
### Section 2 - Rendering Techniques   
2.1 ASimple Area Light Model for GPUs   
2.2 Alpha-to-coverage in Depth   
2.3 Dynamic Parallax Occlusion Mapping with Soft Shadows   
2.4 Pre-Processing of Complex, Static Scenes for Fast Real Time Graphics  
2.5 Overcoming Deferred Shading Drawbacks   
2.6 Normal Mapping without Pre-Computed Tangents   
2.7 Animating Vegetation Using GPU Programs   
2.8 ZT-Buffer Algorithm   
### Section 3 - Image Space  
3.1 Real-Time Depth-of-Field Implemented with a Post-Processing only Technique  
3.2 Selective Supersampling   
3.3 Jump Flooding - An Efficient and Effective Communication on GPU     
### Section 4 - Shadows   
4.1 Cascaded Shadow Maps  
4.2 Multisampling Extension for Gradient Shadow Maps  
4.3 Alias-free Hard Shadows with Geometry Maps   
4.4 Edge Masking and Per-Texel Depth Extent Propagation For Computation Culling During Shadow Mapping   
4.5 Queried Virtual Shadow Maps   
4.6 Real-time Soft Shadows with Shadow Accumulation   
### Section 5 - Environmental Effects   
5.1 Spherical Billboards for Rendering Volumetric Data  
5.2 Per-Pixel Lit, Light Scattering Smoke  
5.3 Volumetric Clouds and Mega Particles   
5.4 Rendering Multiple Layers of Rain with a Post-Processing Composite Effect  
5.5 Animation and Rendering of Underwater God Rays  
### Section 6 - Global Illumination Effects   
6.1Irradiance Volumes for Real Time Rendering  
6.2 Indirect Diffuse and Glossy Illumination on the GPU  
6.3 Interactive Refractions and Caustics Using Image-Space Techniques   
6.4 Splatting of Diffuse and Glossy Indirect Illumination   
### Section 7 - Mobile Devices   
7.1 OpenGL ES 2.0 Shaders forMobileDevices   
7.2 OpenGL ES 2.0 Engine  
7.3 OpenGL ES 2.0 Performance Recommendations forMobileDevices   
7.4 Real-time Tile based Texture Synthesis Using Non-rectangular Grids   
7.5 Cartoon Fire Effects Using OpenGL ES 2.0   
### Section 8 - 3D Engine Design  
8.1 Post-Processing Effects in Design   
8.2 Transparent Shader Data-Binding   
8.3 Designing Plug-in Shaders with HLSL   
8.4 Shader System Integration: Nebula2 and 3ds Max   
### Section 9 - Beyond Pixels and Triangles   
9.1 Large crowds of autonomous animated characters using fragment shaders and level of detail  
9.2 Interactive Image Segmentation Based on GPU Cellular Automata  
9.3 Real-time Cellular Texturing   
9.4 Collision Detection Shader Using Cube-Maps   
9.5 AGPU Panorama Viewer for Generic Camera Models   
9.6 Explicit Early-Z Culling for Efficient Fluid Flow Simulation   
9.7 Storing and Accessing Topology on the GPU: A Case Study on Mass-Spring Systems   
9.8 Implementing High-Quality PRNG on GPU   
9.9 Printf shader for debugging pixel shaders   
  
## ShaderX6- Advanced Rendering Techniques  
  
### 1. Geometry Manipulation  
1.1 Fast Evaluation of Subdivision Surfaces on Direct3D 10 Graphics Hardware     
1.2 Improved Appearance Variety for Geometry Instancing   
1.3 Implementing Real-Time Mesh Simplification Using Programmable Geometry Pipeline on GPU  
### 2.Rendering Techniques  
2.1 Care and Feeding of Normal Vectors   
2.2 Computing Per-Pixel Object Thickness in a Single Render Pass   
2.3 Filtered Tilemaps   
2.4 Parallax Occlusion Mapping Special Feature Rendering  
2.5 Uniform Cubemap for Dynamic Environments   
2.6 Isocube A Cubemap with Uniformly Distributed and Equally Important Texels   
2.7 Practical Geometry Clipmaps for Rendering Terrains in Computer Games   
2.8 Efficient and Practical TileTrees  
2.9 Quantized Ring Clipping   
### 3.Image Space  
3.1 GPU-Based Active Contours for Real-Time Object Tracking     
3.2 Post-tonemapping resolve for high quality HDR antialiasing in D3D10   
3.3 A Fast, Small-Radius GPU Median Filter  
3.4 Per-pixel Motion Blur for Wheels   
3.5 Deferred Rendering using a Stencil Routed K-Buffer  
3.6 HDR meets Black&White 2  
3.7 Robust Order-Independent Transparency via Reverse Depth Peeling in DirectX 10   
### 4.Shadows  
4.1Stable rendering of cascaded shadow maps   
4.2 Approximate Cumulative Distribution Function Shadow Mapping   
4.3 Rendering Filtered Shadows with Exponential Shadow Maps  
4.4 Fitted Virtual Shadow Maps and Shadow Fog   
4.5 Removing Shadow Volume Artifacts  
### 5 Environmental Effects  
5.1 Rendering Realistic Ice Objects     
5.2 Sunlight with Volumetric Light Rays   
5.3 Procedural Ocean Effects   
### 6 Global Illumination  
6.1 Practical Methods for a PRT-based Shader Using Spherical Harmonics  
6.2 Incremental Instant Radiosity  
6.3 Real Time Photon Mapping Approximation on the GPU  
6.4 Interactive Global Illumination with Precomputed Radiance Maps   
### 7 Handheld Devices  
7.1 Shaders Gone Mobile Porting from Direct3D 9.0 to Open GL ES 2.0   
7.2 Efficiently Using Tile-Based GPUs on Mobile Phones  
7.3 Maximal Performance and Image Quality with Minimal Precision  
7.4 Implementing Graphical Benchmark in OpenGL ES 2.0   
7.5 Every Cycle Counts Level of Detail Shaders   
7.6 Shadow Techniques for OpenGL ES 2.0   
### 8 3D Engine Design  
8.1 A Flexible Material System in Design   
8.2 3D Engine Tools with C++CLI   
8.3 Efficient HDR Texture Compression   
### 9 Beyond Pixels & Triangles  
9.1 An Interactive Tour of Voronoi Diagrams on the GPU   
9.2 AMD DirectX 10 Performance Tools and Techniques   
9.3 Real-Time Audio Processing on the GPU   
9.4 n-Body Simulations on the GPU  

## ShaderX7 - Advanced Rendering Techniques
### Section 1 Geometry Manipulation  
1.1 Scalar to Polygonal Extracting Isosurfaces Using Geometry Shaders  
1.2 Fast Tessellation of Quadrilateral Patches for Dynamic Level of Details   
1.3 Dynamic Terrain Rendering on GPU Using Real-Time Tessellation  
1.4 Adaptive Re-Meshing for Displacement Mapping   
1.5 Fast Tessellation of Quadrilateral Patches for Dynamic Level of Details  
### Section 2 Rendering Techniques  
2.1 Quick Noise for GPUs  
2.2 Efficient Soft Particles   
2.3 Simplified High Quality Anti-aliased Lines   
2.4 Fast Skin Shading   
2.5 An Efficient and Physically Plausible Real Time Shading Model  
2.6 Graphics Techniques in Crackdown  
2.7 Deferred Rendering Transparency  
2.8 Deferred Shading with Multisampling Anti-Aliasing in DirectX 10  
2.9 Light Indexed Deferred Rendering   
### Section 3 Image Space  
3.1 Efficient Post-processing with Importance Sampling  
3.2 Efficient Real-Time Motion Blur for Multiple Rigid Objects  
3.3 Real-time Flow-based Image Abstraction  
### Section 4 Shadows  
4.1 Practical Cascaded Shadow Maps  
4.2 A Hybrid Method for Interactive Shadows in Homogeneous Media  
4.3 Real-time dynamic shadows for image-based lighting  
4.4 Facetted Shadow Mapping for Large Dynamic Game Environments  
Section 5 Environment Effects  
5.1 Dynamic Weather Effects  
5.2 Interactive Hydraulic Erosion on the GPU  
5.3 Advanced Geometry for Complex Sky Representation  
### Section 6 Global Illumination  
6.1 Screen Space Ambient Occlusion  
6.2 Image-Space Horizon-Based Ambient Occlusion   
6.3 Deferred Occlusion from Analytic Surfaces  
6.4 Fast Fake Global Illumination  
6.5 Real-Time Subsurface Scattering using Shadow Maps  
6.6 Instant radiosity with GPU photon tracing and approximate indirect shadows  
6.7 Variance methods for Screen-Space Ambient Occlusion  
6.7 Per-Pixel Ambient Occlusion using Geometry Shaders  
### Section 7 Handheld Devices  
7.1 Optimizing your first OpenGL ES Applications  
7.2 Optimised Shaders for Advanced Graphical User Interfaces   
7.3 Facial Animation for Mobile GPUs   
7.4 Augmented Reality on Mobile Phones   
### Section 8 3D Engine Design  
8.1 Cross platform rendering thread: design and implementation  
8.2 Advanced GUI system for games   
8.3 Automatic Load Balancing Shader Framework  
8.4 Game Engine Friendly Occlusion Culling  
8.5 Designing a Renderer for Multiple Lights - The Light Pre-Pass Renderer  
8.6 Using LUV color space with the Light Pre-Pass Renderer  
8.7 Elemental Engine II 
### Section 9 Beyond Pixels & Triangles  
9.1 Sliced Grid: A Memory and Computationally Efficient Data Structure for Particle-based Simulation on the GPU  
9.2 Free-Viewpoint Video on the GPU  
9.3 A Volume Shader for Quantum Voronoi Diagrams inside the 3D Bloch Ball  
9.4 Packing Arbitrary Bit Fields into 16-bit Floating-point Render Targets in DirectX10  
9.5 Interactive Image Morphing Using Thin-Plate Spline  
 
# GPU PRo  
 
## GPU Pro 1  
  
### I Mathematics  
1 GPU Color Quantization  
2 Visualize Your Shadow Map Techniques   
### II Geometry Manipulation  
1 As Simple as Possible Tessellation for Interactive Applications   
2 Rule-Based Geometry Synthesis in Real-Time   
3 GPU-Based NURBS Geometry Evaluation and Rendering   
4 Polygonal-Functional Hybrids for Computer Animation and Games  
### III Rendering Techniques  
1 Quadtree Displacement Mapping with Height Blending   
2 NPR Effects Using the Geometry Shader  
3 Alpha Blending as a Post-Process   
4 Virtual Texture Mapping 101   
### IV Global Illumination  
1 Fast, Stencil-Based Multiresolution Splatting for Indirect Illumination   
2 Screen-Space Directional Occlusion  
3 Real-Time Multi-Bounce Ray-Tracing with Geometry Impostors  
### V Image Space   
1 Anisotropic Kuwahara Filtering on the GPU  
2 Edge Anti-aliasing by Post-Processing  
3 Environment Mapping with Floyd-Steinberg Halftoning  
4 Hierarchical Item Buffers for Granular Occlusion Culling  
5 Realistic Depth of Field in Postproduction   
6 Real-Time Screen Space Cloud Lighting   
7 Screen-Space Subsurface Scattering   
### VI Handheld Devices    
1 Migration to OpenGL ES 2.0  
2 Touchscreen-Based User Interaction   
3 iPhone 3GS Graphics Development and Optimization Strategies   
4 Optimizing a 3D UI Engine for Mobile Devices  
### VII Shadows   
1 Fast Conventional Shadow Filtering   
2 Hybrid Min/Max Plane-Based Shadow Maps   
3 Shadow Mapping for Omnidirectional Light Using Tetrahedron Mapping  
4 Screen Space Soft Shadows   
### VIII 3D Engine Design  
1 Multi-Fragment Effects on the GPU Using Bucket Sort   
2 Parallelized Light Pre-Pass Rendering with the Cell Broadband Engine  
3 Porting Code between Direct3D9 and OpenGL 2.0  
4 Practical Thread Rendering for DirectX 9   
### IX Game Postmortems   
1 Stylized Rendering in Spore   
2 Rendering Techniques in Call of Juarez: Bound in Blood  
3 Making it Large, Beautiful, Fast, and Consistent: Lessons Learned Developing Just Cause 2   
4 Destructible Volumetric Terrain   
### X Beyond Pixels and Triangles  
1 Parallelized Implementation of Universal Visual Computer   
2 Accelerating Virtual Texturing Using CUDA   
3 Efficient Rendering of Highly Detailed Volumetric Scenes with GigaVoxels   
4 Spatial Binning on the GPU   
5 Real-Time Interaction between Particles and the Dynamic Mesh on the GPU   

  
## GPU Pro 2
  
### I Geometry Manipulation   
1 Terrain and Ocean Rendering with Hardware Tessellation  
2 Practical and Realistic Facial Wrinkles Animation  
3 Procedural Content Generation on the GPU   
### II Rendering   
1 Pre-Integrated Skin Shading   
2 Implementing Fur Using Deferred Shading   
3 Large-Scale Terrain Rendering for Outdoor Games   
4 Practical Morphological Antialiasing   
5 Volume Decals   
### III Global Illumination Effects   
1 Temporal Screen-Space Ambient Occlusion   
2 Level-of-Detail and Streaming Optimized Irradiance Normal Mapping  
3 Real-Time One-Bounce Indirect Illumination and Shadows using Ray Tracing   
4 Real-Time Approximation of Light Transport in Translucent Homogenous Media   
5 Diffuse Global Illumination with Temporally Coherent Light Propagation Volumes  
### IV Shadows   
1 Variance Shadow Maps Light-Bleeding Reduction Tricks   
2 Fast Soft Shadows via Adaptive Shadow Maps   
3 Adaptive Volumetric Shadow Maps   
4 Fast Soft Shadows with Temporal Coherence   
5 Mipmapped Screen-Space Soft Shadows   
V Handheld Devices   
1 A Shader-Based eBook Renderer   
2 Post-Processing Effects on Mobile Devices   
3 Shader-Based Water Effects   
### VI 3D Engine Design   
1 Practical, Dynamic Visibility for Games   
2 Shader Amortization using Pixel Quad Message Passing   
3 A Rendering Pipeline for Real-Time Crowds   
### VII GPGPU   
1 2D Distance Field Generation with the GPU   
2 Order-Independent Transparency using Per-Pixel Linked Lists   
3 Simple and Fast Fluids   
4 A Fast Poisson Solver for OpenCL using Multigrid Methods  

  
## GPU Pro 3
  
### I Geometry Manipulation   
1 Vertex Shader Tessellation   
2 Real-Time Deformable Terrain Rendering with DirectX 11  
3 Optimized Stadium Crowd Rendering   
4 Geometric Antialiasing Methods  
### II Rendering   
1 Practical Elliptical Texture Filtering on the GPU  
2 An Approximation to the Chapman Grazing-Incidence Function for Atmospheric Scattering   
3 Volumetric Real-Time Water and Foam Rendering   
4 CryENGINE 3: Three Years of Work in Review   
5 Inexpensive Antialiasing of Simple Objects   
### III Global Illumination Effects   
1 Ray-Traced Approximate Reflections Using a Grid of Oriented Splats  
2 Screen-Space Bent Cones: A Practical Approach  
3 Real-Time Near-Field Global Illumination Based on a Voxel Model   
### IV Shadows    
1 Efficient Online Visibility for Shadow Maps   
2 Depth Rejected Gobo Shadows   
### V 3D Engine Design   
1 Z 3 Culling   
2 A Quaternion-Based Rendering Pipeline  
3 Implementing a Directionally Adaptive Edge AA Filter Using DirectX 11   
4 Designing a Data-Driven Renderer   
### VI GPGPU   
1 Volumetric Transparency with Per-Pixel Fragment Lists   
2 Practical Binary Surface and Solid Voxelization with Direct3D 11   
3 Interactive Ray Tracing Using the Compute Shader in DirectX 11   
  
## GPU Pro 4
  
### I Geometry Manipulation  
1 GPU Terrain Subdivision and Tessellation    
2 Introducing the Programmable Vertex Pulling Rendering Pipeline  
3 A WebGL Globe Rendering Pipeline  
### II Rendering   
1 Practical Planar Reflections Using Cubemaps and Image Proxies   
2 Real-Time Ptex and Vector Displacement   
3 Decoupled Deferred Shading on the GPU   
4 Tiled Forward Shading   
5 Forward+: A Step Toward Film-Style Shading in Real Time  
6 Progressive Screen-Space Multichannel Surface Voxelization  
7 Rasterized Voxel-Based Dynamic Global Illumination   
### III Image Space   
1 The Skylanders SWAP Force Depth-of-Field Shader   
2 Simulating Partial Occlusion in Post-Processing Depth-of-Field Methods  
3 Second-Depth Antialiasing   
4 Practical Framebuffer Compression   
5 Coherence-Enhancing Filtering on the GPU  
### IV Shadows   
1 Real-Time Deep Shadow Maps   
V Game Engine Design   
1 An Aspect-Based Engine Architecture   
2 Kinect Programming with Direct3D 11   
3 A Pipeline for Authored Structural Damage   
### VI GPGPU   
1 Bit-Trail Traversal for Stackless LBVH on DirectCompute   
2 Real-Time JPEG Compression Using DirectCompute  
  
## GPU Pro 5  
  
### I Rendering   
1 Per-Pixel Lists for Single Pass A-Buffer   
2 Reducing Texture Memory Usage by 2-Channel Color Encoding   
3 Particle-Based Simulation of Material Aging  
4 Simple Rasterization-Based Liquids   
### II Lighting and Shading   
1 Physically Based Area Lights   
2 High Performance Outdoor Light Scattering Using Epipolar Sampling   
3 Volumetric Light Effects in Killzone: Shadow Fall   
4 Hi-Z Screen-Space Cone-Traced Reflections   
5 TressFX: Advanced Real-Time Hair Rendering   
6 Wire Antialiasing   
### III Image Space  
1 Screen-Space Grass   
2 Screen-Space Deformable Meshes via CSG with Per-Pixel Linked Lists   
3 Bokeh Effects on the SPU   
### IV Mobile Devices   
1 Realistic Real-Time Skin Rendering on Mobile   
2 Deferred Rendering Techniques on Mobile Devices   
3 Bandwidth Efficient Graphics with ARM Mali GPUs   
4 Efficient Morph Target Animation Using OpenGL ES 3.0  
5 Tiled Deferred Blending   
6 Adaptive Scalable Texture Compression   
7 Optimizing OpenCL Kernels for the ARM Mali-T600 GPUs   
V 3D Engine Design   
1 Quaternions Revisited  
2 glTF: Designing an Open-Standard Runtime Asset Format   
3 Managing Transformations in Hierarchy  
### VI Compute   
1 Hair Simulation in TressFX   
2 Object-Order Ray Tracing for Fully Dynamic Scenes   
3 Quadtrees on the GPU   
4 Two-Level Constraint Solver and Pipelined Local Batching for Rigid Body Simulation on GPUs   
5 Non-separable 2D, 3D, and 4D Filtering with CUDA   
  
## GPU Pro 6  
  
### I Geometry Manipulation  
1 Dynamic GPU Terrain   
2 Bandwidth-Efficient Procedural Meshes in the GPU via Tessellation  
3 Real-Time Deformation of Subdivision Surfaces on Object Collisions  
4 Realistic Volumetric Explosions in Games   
### II Rendering   
1 Next-Generation Rendering in Thief   
2 Grass Rendering and Simulation with LOD   
3 Hybrid Reconstruction Antialiasing   
4 Real-Time Rendering of Physically Based Clouds Using Precomputed Scattering   
5 Sparse Procedural Volume Rendering   
### III Lighting   
1 Real-Time Lighting via Light Linked List   
2 Deferred Normalized Irradiance Probes   
3 Volumetric Fog and Lighting   
4 Physically Based Light Probe Generation on GPU   
5 Real-Time Global Illumination Using Slices   
### IV Shadows   
1 Practical Screen-Space Soft Shadows   
2 Tile-Based Omnidirectional Shadows   
3 Shadow Map Silhouette Revectorization   
### V Mobile Devices   
1 Hybrid Ray Tracing on a PowerVR GPU   
2 Implementing a GPU-Only Particle-Collision System with ASTC 3D Textures and OpenGL ES 3.0   
3 Animated Characters with Shell Fur for Mobile Devices  
4 High Dynamic Range Computational Photography on Mobile GPUs  
### VI Compute 
1 Compute-Based Tiled Culling  
2 Rendering Vector Displacement-Mapped Surfaces in a GPU Ray Tracer   
3 Smooth Probabilistic Ambient Occlusion for Volume Rendering   
### VII 3D Engine Design   
1 Block-Wise Linear Binary Grids for Fast Ray-Casting Operations  
2 Semantic-Based Shader Generation Using Shader Shaker   
3 ANGLE: Bringing OpenGL ES to the Desktop   

## GPU Pro 7  

### I Geometry Manipulation 
1 Deferred Snow Deformation in Rise of the Tomb Raider   
2 Catmull-Clark Subdivision Surfaces   
### II Lighting   
1 Clustered Shading: Assigning Lights Using Conservative Rasterization in DirectX 12  
2 Fine Pruned Tiled Light Lists   
3 Deferred Attribute Interpolation Shading   
4 Real-Time Volumetric Cloudscapes  
### III Rendering   
1 Adaptive Virtual Textures  
2 Deferred Coarse Pixel Shading  
3 Progressive Rendering Using Multi-frame Sampling  
### IV Mobile Devices   
1 Efficient Soft Shadows Based on Static Local Cubemap  
2 Physically Based Deferred Shading on Mobile   
### V 3D Engine Design  
1 Interactive Cinematic Particles  
2 Real-Time BC6H Compression on GPU  
3 A 3D Visualization Tool Used for Test Automation in the Forza Serie  s  
4 Semi-static Load Balancing for Low-Latency Ray Tracing on Heterogeneous Multiple GPUs  
### VI Compute  
1 Octree Mapping from a Depth Camera  
2 Interactive Sparse Eulerian Fluid  
  
 
 
# GPU Zen
 
## GPU Zen 1

### I Geometry Manipulation
1 Attributed Vertex Clouds  
2 Rendering Convex Occluders with Inner Conservative Rasterization  
### II Lighting
1 Stable Indirect Illumination  
2 Participating Media Using Extruded Light Volumes   
### III Rendering
1 Deferred+   
2 Programmable Per-pixel Sample Placement with Conservative Rasterizer  
3 Mobile Toon Shading  
4 High Quality GPU-efficient Image Detail Manipulation  
5 Linear-Light Shading with Linearly Transformed Cosines  
6 Profiling and Optimizing WebGL Applications Using Google Chrome  
### IV Screen Space
1 Scalable Adaptive SSAO  
2 Robust Screen Space Ambient Occlusion  
3 Practical Gather-based Bokeh Depth of Field  
### V Virtual Reality
1 Efficient Stereo and VR Rendering   
2 Understanding, Measuring, and Analyzing VR Graphics Performance  
### VI Compute 
1 Optimizing the Graphics Pipeline with Compute   
2 Real Time Markov Decision Processes for Crowd Simulation  

## GPU Zen 2

### I Rendering 
1. Adaptive GPU Tessellation with Compute Shaders
2. Applying Vectorized Visibility on All frequency Direct Illumination 
3. Non-periodic Tiling of Noise-based Procedural Textures by Aleksandr Kirillov
4. Rendering Surgery Simulation with Vulkan
5. Skinned Decals

### II Environmental Effects 
1. Real-Time Fluid Simulation in Shadow of the Tomb Raider 
2. Real-time Snow Deformation in Horizon Zero Dawn: The Frozen Wilds

### III Shadows (Maurizio Vives)
1. Soft Shadow Approximation for Dappled Light Sources 
2. Parallax-Corrected Cached Shadow Maps

### IV 3D Engine Design 
1. Real-Time Layered Materials Compositing Using Spatial Clustering Encoding
2. Procedural Stochastic Textures by Tiling and Blending
3. A Ray Casting Technique for Baked Texture Generation
4. Writing an efficient Vulkan renderer
5. glTF - Runtime 3D Asset Delivery

### V Ray Tracing (Anton Kaplanyan)
1. Real-Time Ray-Traced One-Bounce Caustics
2. Adaptive Anti-Aliasing using Conservative Rasterization and GPU Ray Tracing

# Ray Tracing Gems

## Ray Tracing Gems 1

### PART 1: RAY TRACING BASICS
1. Ray Tracing Terminology
2. What is a Ray? 
3. Introduction to DirectX Raytracing
4. A Planetarium Dome Master Camera
5. Computing Minima and Maxima of Subarrays

### PART 2: INTERSECTIONS AND EFFICIENCY
6. A Fast and Robust Method for Avoiding Self-Intersection
7. Precision Improvements for Ray/Sphere Intersection
8. Cool Patches: A Geometric Approach to Ray/Bilinear Patch Intersections
9. Multi-Hit Ray Tracing in DXR
10. A Simple Load-Balancing Scheme with High Scaling Efficiency

### PART 3: REFLECTIONS, REFRACTIONS, AND SHADOWS
11. Automatic Handling of Materials in Nested Volumes
12. A Microfacet-Based Shadowing Function to Solve the Bump Terminator Problem
13. Ray Traced Shadows: Maintaining Real-Time Frame Rates
14. Ray-Guided Volumetric Water Caustics in Single Scattering Media with DXR, by Holger Gruen

### PART 4: SAMPLING
15. On the Importance of Sampling
16. Sample Transformations Zoo
17. Ignoring the Inconvenient When Tracing Rays
18. Importance Sampling of Many Lights on the GPU

### PART 5: DENOISING AND FILTERING
19. Cinematic Rendering in UE4 with Real-Time Ray Tracing and Denoising
20. Texture Level of Detail Strategies for Real-Time Ray Tracing
21. Simple Environment Map Filtering Using Ray Cones and Ray Differentials
22. Improving Temporal Antialiasing with Adaptive Ray Tracing

### PART 6: HYBRID APPROACHES AND SYSTEMS
23. Interactive Light Map and Irradiance Volume Preview in Frostbite
24. Real-Time Global Illumination with Photon Mapping
25. Hybrid Rendering for Real-Time Ray Tracing
26. Deferred Hybrid Path Tracing
27. Interactive Ray Tracing Techniques for High-Fidelity Scientific Visualization

### PART 7: GLOBAL ILLUMINATION
28. Ray Tracing Inhomogeneous Volumes
29. Efficient Particle Volume Splatting in a Ray Tracer
30. Caustics Using Screen Space Photon Mapping
31. Variance Reduction via Footprint Estimation in the Presence of Path Reuse
32. Accurate Real-Time Specular Reflections with Radiance Caching

## Ray Tracing Gems 2

### PART I: Ray Tracing Foundations  
1. A Breakneck Summary of Photographic Terms (and Their Utility to Ray Tracing), by Trevor David Black
2. Ray Axis-Aligned Bounding Box Intersection, by Peter Shirley, Ingo Wald, and Adam Marrs
3. Essential Ray Generation Shaders, by Morgan McGuire and Zander Majercik
4. Hacking the Shadow Terminator, by Johannes Hanika
5. Sampling Textures with Missing Derivatives, by Maksim Aizenshtein and Matt Pharr
6. Differential Barycentric Coordinates, by Tomas Akenine-Möller
7. Texture Coordinate Gradients Estimation for Ray Cones, by Wessam Bahnassi
8. Reflection and Refraction Formulas, by Eric Haines
9. The Schlick Fresnel Approximation, by Zander Majercik
10. Refraction Ray Cones for Texture Level of Detail, by Jakub Boksansky, Cyril Crassin, and Tomas Akenine-Möller
11. Handling Translucency with Real-Time Ray Tracing, by Tianyi "Tanki" Zhang
12. Motion Blur Corner Cases, by Christopher Kulla and Thiago Ize
13. Fast Spectral Upsampling of Volume Attenuation, by Johannes Jendersie
14. The Reference Path Tracer, by Jakub Boksansky and Adam Marrs
### PART II: APIs and Tools  
15. The Shader Binding Table Demystified, by Will Usher
16. Introduction to Vulkan Ray Tracing, by Matthew Rusch, Neil Bickford, and Nuno Subtil
17. Using Bindless Resources with DirectX Raytracing, by Matt Pettineo
18. WebRays: Ray Tracing on the Web, by Nick Vitsas, Anastasios Gkaravelis, Andreas A. Vasilakis, and Georgios Papaioannou
19. Visualizing and Communicating Errors in Rendered Images, by Pontus Andersson, Jim Nilsson, and Tomas Akenine-Möller
### PART III: Sampling  
20. Multiple Importance Sampling 101, by Anders Lindqvist
21. The Alias Method for Sampling Discrete Distributions, by Chris Wyman
22. Weighted Reservoir Sampling: Randomly Sampling Streams, by Chris Wyman
23. Rendering Many Lights with Grid-Based Reservoirs, by Jakub Boksansky, Paula Jukarainen, and Chris Wyman
24. Using Blue Noise for Ray Traced Soft Shadows, by Alan Wolfe
### PART IV: Shading and Effects  
25. Temporally Reliable Motion Vectors for Better Use of Temporal Information, by Zheng Zeng, Shiqiu Liu, Jinglei Yang, Lu Wang, and Ling-Qi Yan
26. Ray Traced Level of Detail Cross-Fades Made Easy, by Holger Gruen
27. Ray Tracing Decals, by Wessam Bahnassi
28. Billboard Ray Tracing for Impostors and Volumetric Effects, by Felix Brüll, Robin Fynn Diedrichs, and Thorsten Grosch
29. Hybrid Ray Traced and Image-Space Refractions, by Daniel Parhizgar and Marcus Svensson
30. Real-Time Ray Traced Caustics, by Xueqing Yang and Yaobin Ouyang
31. Tilt-Shift Rendering Using a Thin Lens Model, by Andrew Kensler
### PART V: Intersection  
32. Fast and Robust Ray/OBB Intersection Using the Lorentz Transformation, by Rodolfo Sabino, Creto Augusto Vidal, Joaquim Bento Cavalcante-Neto, and José Gilvan Rodrigues Maia
33. Real-Time Rendering of Complex Fractals, by Vinícius da Silva, Tiago Novello, Hélio Lopes, and Luiz Velho
34. Improving Numerical Precision in Intersection Programs, by Ingo Wald
35. Ray Tracing of Blobbies, by Manuele Sabbadin and Marc Droske
36. Curved Ray Traversal, by Christiaan Gribble
37. Ray-Tracing Small Voxel Scenes, by Dylan Lacewell
### PART VI: Performance  
38. CPU Performance in DXR, by Peter Morley
39. Inverse Transform Sampling Using Ray Tracing Hardware, by Nate Morrical and Stefan Zellmann
40. Accelerating Boolean Visibility Operations Using RTX Visibility Masks, by Dirk Gerrit van Antwerpen and Oliver Klehm
41. Practical Spatial Hash Map Updates, by Pascal Gautron
42. Efficient Spectral Rendering on the GPU for Predictive Rendering, by David Murray, Alban Fichet, and Romain Pacanowski
43. Efficient Unbiased Volume Path Tracing on the GPU, by Nikolai Hofmann and Alex Evans
44. Path Tracing RBF Particle Volumes, by Aaron Knoll, Gregory P. Johnson, and Johannes Meng
45. Fast Volumetric Gradient Shading Approximations for Scientific Ray Tracing, by Carson Brownlee and David DeMarle
### PART VII: Ray Tracing in the Wild  
46. Ray Tracing in Control, by Juha Sjöholm, Paula Jukarainen, and Tatu Aalto
47. Light Sampling in Quake 2 Using Subset Importance Sampling, by Tobias Zirr
48. Ray Tracing in Fortnite, by Patrick Kelly, Yuriy O'Donnell, Kenzo ter Elst, Juan Cañada, and Evan Hart
49. ReBLUR: A Hierarchical Recurrent Denoiser, by Dmitry Zhdan
50. Practical Solutions for Ray Tracing Content Compatibility in Unreal Engine 4, by Evan Hart

# Advances in Real-Time Rendering in 3D Graphics and Games

## SIGGRAPH 2023    
HypeHype Mobile Rendering Architecture     
Nubis3: Methods (and madness) to model and render immersive real-time voxel-based clouds    
Large-Scale Terrain Rendering in Call of Duty    
Authoring Materials That Matters - Substrate in Unreal Engine 5    
The Rendering of The Callisto Protocol     

## SIGGRAPH 2022
Bisection Based Triangulation of Catmull Clark Subdivision  
Lumen: Real-time Global Illumination in Unreal Engine 5  
Ray Tracing Open Worlds in Unreal Engine 5  
Nubis, Evolved: Real-Time Volumetric Clouds for Skies, Environments, and VFX  
Probe-based lighting, strand-based hair system, and physical hair shading in Unity’s ‘Enemies’  
Real-time Cluster Path Tracing for Remote Rendering  
Rendering Water in Horizon Forbidden West  

## SIGGRAPH 2021
Improved Spatial Upscaling through FidelityFX Super Resolution for Real-Time Game Engines  
Experimenting with Concurrent Binary Trees for Large Scale Terrain Rendering  
A Deep Dive into Nanite Virtualized Geometry  
Large-Scale Global Illumination at Activision  
Real-Time Samurai Cinema: Lighting, Atmosphere, and Tone mapping in Ghost of Tsushima  
Radiance Caching for Real-time Global Illumination  
Global Illumination Based on Surfels  

## SIGGRAPH 2020
Software-Based Variable Rate Shading in Call of Duty: Modern Warfare  
Rendering the Hellscape of Doom Eternal  
From Ray to Path Tracing: Navigating through Dimensions  
Precomputed Lighting Advances in Call of Duty: Modern Warfare  
The Technical Art of The Last of Us Part II  

## SIGGRAPH 2019
A Journey Through Implementing Multiscattering BRDFs and Area Lights  
Leveraging Real-Time Ray Tracing to build a Hybrid Game Engine  
Strand-based Hair Rendering in Frostbite  
Mesh Shading: Towards Greater Efficiency of Geometry Processing  
Interactive Wind and Vegetation in 'God of War'  
Multi-resolution Ocean Rendering in Crest Ocean System  
Creating the Atmospheric World of Red Dead Redemption 2: A Complete and Integrated Solution  

## SIGGRAPH 2018
The Challenges of Rendering an Open World in Far Cry 5  
Material Advances in Call of Duty: WWII  
A Life of a Bokeh  
The Road toward Unified Rendering with Unity’s High Definition Render Pipeline  
Efficient Screen-Space Subsurface Scattering Using Burley’s Normalized Diffusion in Real-Time  
Real-Time rendering’s next frontier: Adopting lessons from offline ray tracing to real-time ray tracing for practical pipelines  
Real-Time Ray Tracing of Correct* Soft Shadows  

## SIGGRAPH 2017
Nubis: Authoring Real-Time Volumetric Cloudscapes with the Decima Engine  
Crest: Novel Ocean Rendering Techniques in an Open Source Framework  
Precomputed lighting in Call of Duty: Infinite Warfare  
Dynamic Temporal Antialiasing in Call of Duty: Infinite Warfare  
The Destiny Particle Architecture  
Decima Engine: Advances in Lighting and AA  
Optimized pixel-projected reflections for planar reflectors      
Improved Culling for Tiled and Clustered Rendering  

## SIGGRAPH 2016
Volumetric Global Illumination at Treyarch  
Deferred Lighting in Uncharted 4  
Real-Time Area Lighting: a Journey from Research to Production  
Rendering Rapids in Uncharted 4  
Aggregate G-Buffer Anti-Aliasing in Unreal Engine 4  
The devil is in the details:  idTech 666  
Temporal Antialiasing in Uncharted 4     
Filmic SMAA: Sharp Morphological and Temporal Antialiasing  
The Process of Creating Volumetric-based Materials in Uncharted 4  
Technical Art of Uncharted 4  

## SIGGRAPH 2015
Towards Unified and Physically-Based Volumetric Lighting in Frostbite  
Stochastic Screen-Space Reflections  
The Real-time Volumetric Cloudscapes of Horizon: Zero Dawn  
A Novel Sampling Algorithm for Fast and Stable Real-Time Volume Rendering  
Sparkly but not too Sparkly! A Stable and Robust Procedural Sparkle Effect  
Multi-Scale Global Illumination in Quantum Break  
Rendering the Alternate History of The Order: 1886  
Learning from Failure: a Survey of Promising, Unconventional and Mostly Abandoned Renderers for ‘Dreams PS4’, a Geometrically Dense, Painterly UGC Game’  
Dynamic Occlusion with Signed Distance Fields  
GPU-Driven Rendering Pipelines  

## SIGGRAPH 2014
Next Generation Post Processing in Call of Duty: Advanced Warfare  
High-Quality Temporal Supersampling  
Rendering Techniques in Ryse: Son of Rome  
Hybrid Reconstruction Anti-Aliasing  
Volumetric Fog: Unified Compute Shader-Based Solution to Atmospheric Scattering  
Real-time Lighting via Light Linked List  
Reflection System in Thief  
Tessellation in Call of Duty: Ghosts  
Reflections and Volumetrics of Killzone Shadow Fall  
Creating Content to Drive Destiny’s Investment Game: One Solution to Rule Them All  
Character Heads Creation Pipeline and Rendering in Destiny  
Destiny Character-Animation System and Lessons Learned  

## SIGGRAPH 2013
Mythic Science Fiction In Real-Time: Destiny Rendering Engine  
Pixel Synchronization: Solving Old Graphics Problems With New Data Structures   
Practical Clustered Deferred And Forward Shading  
The Redengine 3 Character Pipeline  
Oceans On A Shoestring : Shape Representation, Meshing And Shading  
Graphics Gems From Cryengine 3  
 

## SIGGRAPH 2012
Scalable High Quality Motion Blur and Ambient Occlusion  
Real-Time Global Illumination and Reflections in Dust 514  
Separable Subsurface Scattering & Photorealistic Eyes Rendering  
Accelerating Rendering Pipelines Using Bidirectional Iterative Reprojection  
CSM Scrolling, an Acceleration Technique for the Rendering of Cascaded Shadow Maps  
The Technology Behind the “Unreal Engine 4 Elemental demo”  
Rock-Solid Shading: Image Stability without Sacrificing Detail  
Dynamic Sand Simulation and Rendering in Journey  
Graphics gems for games: Findings from Avalanche Studios  


## SIGGRAPH 2011
Making Game Worlds from Polygon Soup: Visibility, Spatial hierarchy and Rendering Challenges  
Rendering in Cars 2  
Secrets of CryENGINE 3  Graphics Technology  
Two uses of Voxels in LittleBigPlanet2’s graphics engine  
More Performance! Five Rendering Ideas from Battlefield 3 and Need For Speed: The Run  
Physically-based lighting in Call of Duty: Black Ops  
Real-time image quilting: Arbitrary material blends, invisible seams, and no repeats  
Dynamic lighting in God of War 3  
Pre-Integrated Skin Shading  

## SIGGRAPH 2010
Rendering techniques in Toy Story 3  
A Real-Time Radiosity Architecture for Video Game  
Real-Time Order Independent Transparency and Indirect Illumination using Direct3D 11  
CryENGINE 3: Reaching the Speed of Light  
Sample Distribution Shadow Maps  
Adaptive Volumetric Shadow Maps  
Uncharted 2: Character Lighting and Shading  
Destruction Masking in Frostbite 2 using Volume Distance Fields  
Water Flow in Portal 2  

## SIGGRAPH 2009
Lighting Research at Bungie  
Light Propagation Volumes in CryEngine 3  
The Light Pre-Pass Renderer: Renderer Design for Efficient Support of Multiple Lights  
Rendering Technology at Black Rock Studios  
When Fuzzy is Good: Advances in Filtering Techniques  
Graphics Engine Postmortem from LittleBigPlanet  
